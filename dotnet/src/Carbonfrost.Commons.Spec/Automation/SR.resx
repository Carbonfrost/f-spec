<?xml version="1.0" encoding="utf-8"?>
<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, srgen, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, srgen, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</value>
  </resheader>
  <data name="AllWhitespace" xml:space="preserve">
    <value>Argument can't be all whitespace.</value>
  </data>
  <data name="BadEpsilonComparerTypes" xml:space="preserve">
    <value>Can't apply approximate comparisons to `{0}'.</value>
  </data>
  <data name="CannotAliasDifferentTagTypes" xml:space="preserve">
    <value>Cannot create an alias when tags have different types</value>
  </data>
  <data name="CannotAssertAssertExceptions" xml:space="preserve">
    <value>Can't use `ExpectedExceptionAttribute` or `ThrowsAttribute` on a test that throws assertions exceptions if those exceptions might be caught by the attribute.  Replace with `Assert.Throws`.</value>
  </data>
  <data name="CannotAssertTypeOnNullActual" xml:space="preserve">
    <value>Can't check type of null actual values.  Assert that the value is non-null before trying to assert its type.</value>
  </data>
  <data name="CannotFindDataField" xml:space="preserve">
    <value>Couldn't find data field {0} on test class.</value>
  </data>
  <data name="CannotFindDataProperty" xml:space="preserve">
    <value>Couldn't find data property {0} on test class.</value>
  </data>
  <data name="CannotFindFixture" xml:space="preserve">
    <value>Can't find fixture '{0}' in ({1})</value>
  </data>
  <data name="CannotTreatAsDictionaryOrGroupings" xml:space="preserve">
    <value>Can't assert that instance of `{0}' has keys because it doesn't support it.</value>
  </data>
  <data name="CannotUseNullOnValueType" xml:space="preserve">
    <value>Can't use null or not-null on value type {0}.  Assert that the value is a reference type before trying to assert whether it is null.</value>
  </data>
  <data name="CardinalityMinGreaterThanMax" xml:space="preserve">
    <value>Make sure that Between() specifies min &lt; max</value>
  </data>
  <data name="CastRequiredByMatcherFailure" xml:space="preserve">
    <value>Invalid cast required by `{0}'.  This conversion may have been implicit; make sure that the type is supported by the assertion you are trying to use.</value>
  </data>
  <data name="ConsistentlyElapsedBefore" xml:space="preserve">
    <value>Elapsed before {0}.  Consistently expected to:</value>
  </data>
  <data name="CouldNotLoadType" xml:space="preserve">
    <value>Couldn't load the required type: {0}</value>
  </data>
  <data name="DataPropertyIncorrectGetter" xml:space="preserve">
    <value>Expected data property to have a get method and to be of type IEnumerable&lt;object[]&gt; or another compatible IEnumerable&lt;&gt; return type.</value>
  </data>
  <data name="EventuallyTimedOutAfter" xml:space="preserve">
    <value>Timed out after {0}.  Eventually expected to:</value>
  </data>
  <data name="ExactlyOnePlural" xml:space="preserve">
    <value>Don't use Exactly(0).Item() or No.Item() -- use Items</value>
  </data>
  <data name="ExactlyOneSingular" xml:space="preserve">
    <value>Don't use Exactly(1).Items() or Single.Items() -- use Item</value>
  </data>
  <data name="ExpectedAllElementsTo" xml:space="preserve">
    <value>Expected all elements to:</value>
  </data>
  <data name="ExpectedAnyElementTo" xml:space="preserve">
    <value>Expected any element to:</value>
  </data>
  <data name="ExpectedAssignableFrom" xml:space="preserve">
    <value>Expected assignable from {Expected}</value>
  </data>
  <data name="ExpectedAtLeastTo" xml:space="preserve">
    <value>Expected at least {0} to:</value>
  </data>
  <data name="ExpectedAtMostTo" xml:space="preserve">
    <value>Expected at most {0} to:</value>
  </data>
  <data name="ExpectedBetween" xml:space="preserve">
    <value>Expected to be between</value>
  </data>
  <data name="ExpectedBetweenTo" xml:space="preserve">
    <value>Expected between {0} and {1} to:</value>
  </data>
  <data name="ExpectedContains" xml:space="preserve">
    <value>Expected to contain {Expected}</value>
  </data>
  <data name="ExpectedContainsSubstring" xml:space="preserve">
    <value>Expected to contain substring "{Expected}"</value>
  </data>
  <data name="ExpectedDistinct" xml:space="preserve">
    <value>Expected to be distinct</value>
  </data>
  <data name="ExpectedEmpty" xml:space="preserve">
    <value>Expected empty</value>
  </data>
  <data name="ExpectedEndWith" xml:space="preserve">
    <value>Expected to end with {Expected}</value>
  </data>
  <data name="ExpectedEndWithSubstring" xml:space="preserve">
    <value>Expected to end with substring {Expected}</value>
  </data>
  <data name="ExpectedEqual" xml:space="preserve">
    <value>Expected equal</value>
  </data>
  <data name="ExpectedEqualDownloadContents" xml:space="preserve">
    <value>Expected to equal download contents {Source}</value>
  </data>
  <data name="ExpectedEqualFileContents" xml:space="preserve">
    <value>Expected to equal file contents {FileName}</value>
  </data>
  <data name="ExpectedExactly" xml:space="preserve">
    <value>Expected exactly {0} to:</value>
  </data>
  <data name="ExpectedFalse" xml:space="preserve">
    <value>Expected false</value>
  </data>
  <data name="ExpectedGreaterThan" xml:space="preserve">
    <value>Expected &gt; {Expected}</value>
  </data>
  <data name="ExpectedGreaterThanOrEqualTo" xml:space="preserve">
    <value>Expected &gt;= {Expected}</value>
  </data>
  <data name="ExpectedHaveCount" xml:space="preserve">
    <value>Expected to have count {Expected}</value>
  </data>
  <data name="ExpectedHaveKey" xml:space="preserve">
    <value>Expected key</value>
  </data>
  <data name="ExpectedHaveKeyWithValue" xml:space="preserve">
    <value>Expected key with value</value>
  </data>
  <data name="ExpectedHaveLength" xml:space="preserve">
    <value>Expected to have length {Expected}</value>
  </data>
  <data name="ExpectedHaveSingle" xml:space="preserve">
    <value>Expected single item</value>
  </data>
  <data name="ExpectedInstanceOf" xml:space="preserve">
    <value>Expected instance of {Expected}</value>
  </data>
  <data name="ExpectedLessThan" xml:space="preserve">
    <value>Expected &lt; {Expected}</value>
  </data>
  <data name="ExpectedLessThanOrEqualTo" xml:space="preserve">
    <value>Expected &lt;= {Expected}</value>
  </data>
  <data name="ExpectedMatch" xml:space="preserve">
    <value>Expected to match {Expected}</value>
  </data>
  <data name="ExpectedMemberwiseEqual" xml:space="preserve">
    <value>Expected memberwise-equal</value>
  </data>
  <data name="ExpectedNotAllElementsTo" xml:space="preserve">
    <value>Expected not all elements to:</value>
  </data>
  <data name="ExpectedNotAnyElementTo" xml:space="preserve">
    <value>Expected not any element to:</value>
  </data>
  <data name="ExpectedNull" xml:space="preserve">
    <value>Expected null</value>
  </data>
  <data name="ExpectedOverlap" xml:space="preserve">
    <value>Expected overlap</value>
  </data>
  <data name="ExpectedReferenceType" xml:space="preserve">
    <value>Expected reference type</value>
  </data>
  <data name="ExpectedSame" xml:space="preserve">
    <value>Expected same</value>
  </data>
  <data name="ExpectedSatisfyAll" xml:space="preserve">
    <value>Expected to satisfy all:</value>
  </data>
  <data name="ExpectedSatisfyAny" xml:space="preserve">
    <value>Expected to satisfy any:</value>
  </data>
  <data name="ExpectedSequenceEqual" xml:space="preserve">
    <value>Expected sequence-equal</value>
  </data>
  <data name="ExpectedSetEqual" xml:space="preserve">
    <value>Expected set-equal</value>
  </data>
  <data name="ExpectedStartWith" xml:space="preserve">
    <value>Expected to start with {Expected}</value>
  </data>
  <data name="ExpectedStartWithSubstring" xml:space="preserve">
    <value>Expected to start with substring {Expected}</value>
  </data>
  <data name="ExpectedThrows" xml:space="preserve">
    <value>Expected to throw "{Expected}"</value>
  </data>
  <data name="ExpectedTo" xml:space="preserve">
    <value>Expected to:</value>
  </data>
  <data name="ExpectedTrue" xml:space="preserve">
    <value>Expected true</value>
  </data>
  <data name="ExpectedValueType" xml:space="preserve">
    <value>Expected value type</value>
  </data>
  <data name="ExplicitPassNotSet" xml:space="preserve">
    <value>Test is configured to require explicitly passing, but test completed without invoking Assert.Pass().</value>
  </data>
  <data name="FactMethodParamCount" xml:space="preserve">
    <value>Fact method {0} cannot have parameters</value>
  </data>
  <data name="Failed" xml:space="preserve">
    <value>Explicitly failed</value>
  </data>
  <data name="FailedToLoadAssembly" xml:space="preserve">
    <value>Not an assembly: {0}</value>
  </data>
  <data name="FailedToLoadAssemblyGeneralIO" xml:space="preserve">
    <value>Assembly file could not load: {0} ({1})</value>
  </data>
  <data name="FailedToLoadAssemblyPath" xml:space="preserve">
    <value>Assembly file not found: {0}</value>
  </data>
  <data name="FixtureParserIllegalTabs" xml:space="preserve">
    <value>Illegal tabs</value>
  </data>
  <data name="FixtureParserMissingFieldSeparator" xml:space="preserve">
    <value>Expected `:'</value>
  </data>
  <data name="HaveLengthWorksWith" xml:space="preserve">
    <value>Can't assert length with objects of this type.  It works only for strings and arrays.  Investigate asserting on count for collections instead.</value>
  </data>
  <data name="InvalidContextLines" xml:space="preserve">
    <value>invalid number of context lines</value>
  </data>
  <data name="InvalidPackageReference" xml:space="preserve">
    <value>invalid package reference syntax</value>
  </data>
  <data name="InvalidRandomSeed" xml:space="preserve">
    <value>invalid random seed</value>
  </data>
  <data name="InvalidRegex" xml:space="preserve">
    <value>invalid regex: {0}</value>
  </data>
  <data name="InvalidTimeSpan" xml:space="preserve">
    <value>invalid time span</value>
  </data>
  <data name="InvalidVerify" xml:space="preserve">
    <value>invalid verification mode</value>
  </data>
  <data name="LabelActual" xml:space="preserve">
    <value>Actual</value>
  </data>
  <data name="LabelActualCount" xml:space="preserve">
    <value>Actual count</value>
  </data>
  <data name="LabelBoundsExclusive" xml:space="preserve">
    <value>Bounds exclusive</value>
  </data>
  <data name="LabelComparer" xml:space="preserve">
    <value>Comparer</value>
  </data>
  <data name="LabelComparison" xml:space="preserve">
    <value>Comparison</value>
  </data>
  <data name="LabelDiff" xml:space="preserve">
    <value>Diff</value>
  </data>
  <data name="LabelDifferences" xml:space="preserve">
    <value>Differences</value>
  </data>
  <data name="LabelExpected" xml:space="preserve">
    <value>Expected</value>
  </data>
  <data name="LabelFileName" xml:space="preserve">
    <value>File name</value>
  </data>
  <data name="LabelFlags" xml:space="preserve">
    <value>Flags</value>
  </data>
  <data name="LabelGiven" xml:space="preserve">
    <value>Given</value>
  </data>
  <data name="LabelHigh" xml:space="preserve">
    <value>High</value>
  </data>
  <data name="LabelIndexes" xml:space="preserve">
    <value>Indexes</value>
  </data>
  <data name="LabelLow" xml:space="preserve">
    <value>Low</value>
  </data>
  <data name="LabelMatchers" xml:space="preserve">
    <value>Matchers</value>
  </data>
  <data name="LabelMemberFilter" xml:space="preserve">
    <value>Member filter</value>
  </data>
  <data name="LabelPredicate" xml:space="preserve">
    <value>Predicate</value>
  </data>
  <data name="LabelProperty" xml:space="preserve">
    <value>Property</value>
  </data>
  <data name="LabelSource" xml:space="preserve">
    <value>Source</value>
  </data>
  <data name="LabelSubject" xml:space="preserve">
    <value>Subject</value>
  </data>
  <data name="MultiAccessorsTheoryParameterMismatch" xml:space="preserve">
    <value>Invalid cross join: Theory method must have exactly as many parameters as members in the data source.</value>
  </data>
  <data name="MultipleTestUnitFactories" xml:space="preserve">
    <value>Method has more than one fact or theory attribute</value>
  </data>
  <data name="NegativeCardinality" xml:space="preserve">
    <value>Make sure that AtLeast or min value is non-negative</value>
  </data>
  <data name="NegativeTimeout" xml:space="preserve">
    <value>Timeout must be positive or exactly equal to 0 or -1 to indicate an infinite timeout.</value>
  </data>
  <data name="NoException" xml:space="preserve">
    <value>(No exception)</value>
  </data>
  <data name="NoSelfTestsAvailable" xml:space="preserve">
    <value>Can't self-test; no tests configured in this build.</value>
  </data>
  <data name="NoTestMethods" xml:space="preserve">
    <value>Test class has no test methods</value>
  </data>
  <data name="NoTestSubjects" xml:space="preserve">
    <value>Test class has no test subjects</value>
  </data>
  <data name="NotExpectedAssignableFrom" xml:space="preserve">
    <value>Not expected to be assignable from {Expected}</value>
  </data>
  <data name="NotExpectedBetween" xml:space="preserve">
    <value>Not expected to be between</value>
  </data>
  <data name="NotExpectedContains" xml:space="preserve">
    <value>Not expected to contain {Expected}</value>
  </data>
  <data name="NotExpectedContainsSubstring" xml:space="preserve">
    <value>Not expected to contain substring "{Expected}"</value>
  </data>
  <data name="NotExpectedDistinct" xml:space="preserve">
    <value>Not expected to be distinct</value>
  </data>
  <data name="NotExpectedEmpty" xml:space="preserve">
    <value>Not expected to be empty</value>
  </data>
  <data name="NotExpectedEndWith" xml:space="preserve">
    <value>Not expected to end with {Expected}</value>
  </data>
  <data name="NotExpectedEndWithSubstring" xml:space="preserve">
    <value>Not expected to end with substring {Expected}</value>
  </data>
  <data name="NotExpectedEqual" xml:space="preserve">
    <value>Not expected to be equal to</value>
  </data>
  <data name="NotExpectedEqualDownloadContents" xml:space="preserve">
    <value>Not expected to equal download contents {Source}</value>
  </data>
  <data name="NotExpectedEqualFileContents" xml:space="preserve">
    <value>Not expected to equal file contents {FileName}</value>
  </data>
  <data name="NotExpectedFalse" xml:space="preserve">
    <value>Not expected to be false</value>
  </data>
  <data name="NotExpectedGreaterThan" xml:space="preserve">
    <value>Not expected to be &gt; {Expected}</value>
  </data>
  <data name="NotExpectedGreaterThanOrEqualTo" xml:space="preserve">
    <value>Not expected to be &gt;= {Expected}</value>
  </data>
  <data name="NotExpectedHaveCount" xml:space="preserve">
    <value>Not expected to have count {Expected}</value>
  </data>
  <data name="NotExpectedHaveKey" xml:space="preserve">
    <value>Expected not to have key {Expected}</value>
  </data>
  <data name="NotExpectedHaveKeyWithValue" xml:space="preserve">
    <value>Expected not to have key with value</value>
  </data>
  <data name="NotExpectedHaveLength" xml:space="preserve">
    <value>Not expected to have length {Expected}</value>
  </data>
  <data name="NotExpectedHaveSingle" xml:space="preserve">
    <value>Not expected to have single item</value>
  </data>
  <data name="NotExpectedInstanceOf" xml:space="preserve">
    <value>Expected not instance of {Expected}</value>
  </data>
  <data name="NotExpectedLessThan" xml:space="preserve">
    <value>Not expected to be &lt; {Expected}</value>
  </data>
  <data name="NotExpectedLessThanOrEqualTo" xml:space="preserve">
    <value>Not expected to be &lt;= {Expected}</value>
  </data>
  <data name="NotExpectedMatch" xml:space="preserve">
    <value>Not expected to match {Expected}</value>
  </data>
  <data name="NotExpectedMemberwiseEqual" xml:space="preserve">
    <value>Not expected to be memberwise-equal</value>
  </data>
  <data name="NotExpectedNull" xml:space="preserve">
    <value>Not expected to be null</value>
  </data>
  <data name="NotExpectedOverlap" xml:space="preserve">
    <value>Not expected to overlap</value>
  </data>
  <data name="NotExpectedReferenceType" xml:space="preserve">
    <value>Expected not reference type</value>
  </data>
  <data name="NotExpectedSame" xml:space="preserve">
    <value>Not expected to be same</value>
  </data>
  <data name="NotExpectedSatisfyAll" xml:space="preserve">
    <value>Not expected to satisfy all</value>
  </data>
  <data name="NotExpectedSatisfyAny" xml:space="preserve">
    <value>Not expected to satisfy any</value>
  </data>
  <data name="NotExpectedSequenceEqual" xml:space="preserve">
    <value>Not expected to be sequence-equal</value>
  </data>
  <data name="NotExpectedSetEqual" xml:space="preserve">
    <value>Not expected to be set-equal</value>
  </data>
  <data name="NotExpectedStartWith" xml:space="preserve">
    <value>Not expected to start with {Expected}</value>
  </data>
  <data name="NotExpectedStartWithSubstring" xml:space="preserve">
    <value>Not expected to start with substring {Expected}</value>
  </data>
  <data name="NotExpectedThrows" xml:space="preserve">
    <value>Not expected to throw "{Expected}"</value>
  </data>
  <data name="NotExpectedTo" xml:space="preserve">
    <value>Not expected to:</value>
  </data>
  <data name="NotExpectedTrue" xml:space="preserve">
    <value>Not expected to be true</value>
  </data>
  <data name="NotExpectedValueType" xml:space="preserve">
    <value>Expected not value type</value>
  </data>
  <data name="NotPredicateAssignableFrom" xml:space="preserve">
    <value>not be assignable from {Expected}</value>
  </data>
  <data name="NotPredicateBetween" xml:space="preserve">
    <value>not to be between {Low} {High} {BoundsExclusive:B:(exclusive)}</value>
  </data>
  <data name="NotPredicateContains" xml:space="preserve">
    <value>not to contain {Expected}</value>
  </data>
  <data name="NotPredicateContainsSubstring" xml:space="preserve">
    <value>not to contain substring "{Expected}"</value>
  </data>
  <data name="NotPredicateDistinct" xml:space="preserve">
    <value>not be distinct</value>
  </data>
  <data name="NotPredicateEmpty" xml:space="preserve">
    <value>not be empty</value>
  </data>
  <data name="NotPredicateEndWith" xml:space="preserve">
    <value>not end with {Expected}</value>
  </data>
  <data name="NotPredicateEndWithSubstring" xml:space="preserve">
    <value>not end with substring {Expected}</value>
  </data>
  <data name="NotPredicateEqual" xml:space="preserve">
    <value>not be equal to {Expected}</value>
  </data>
  <data name="NotPredicateEqualDownloadContents" xml:space="preserve">
    <value>not to equal download contents {Source}</value>
  </data>
  <data name="NotPredicateEqualFileContents" xml:space="preserve">
    <value>not to equal file contents {FileName}</value>
  </data>
  <data name="NotPredicateFalse" xml:space="preserve">
    <value>not be false</value>
  </data>
  <data name="NotPredicateGreaterThan" xml:space="preserve">
    <value>not be &gt; {Expected}</value>
  </data>
  <data name="NotPredicateGreaterThanOrEqualTo" xml:space="preserve">
    <value>not be &gt;=not  {Expected}</value>
  </data>
  <data name="NotPredicateHaveCount" xml:space="preserve">
    <value>not have count {Expected}</value>
  </data>
  <data name="NotPredicateHaveKey" xml:space="preserve">
    <value>not have key {Expected}</value>
  </data>
  <data name="NotPredicateHaveKeyWithValue" xml:space="preserve">
    <value>not have key with value {ExpectedKey}={ExpectedValue}</value>
  </data>
  <data name="NotPredicateHaveLength" xml:space="preserve">
    <value>not have length {Expected}</value>
  </data>
  <data name="NotPredicateHaveSingle" xml:space="preserve">
    <value>not have single item</value>
  </data>
  <data name="NotPredicateInstanceOf" xml:space="preserve">
    <value>not be instance of {Expected}</value>
  </data>
  <data name="NotPredicateLessThan" xml:space="preserve">
    <value>not be &lt; {Expected}</value>
  </data>
  <data name="NotPredicateLessThanOrEqualTo" xml:space="preserve">
    <value>not be &lt;=not  {Expected}</value>
  </data>
  <data name="NotPredicateMatch" xml:space="preserve">
    <value>not match {Expected}</value>
  </data>
  <data name="NotPredicateMemberwiseEqual" xml:space="preserve">
    <value>not be memberwise-equal</value>
  </data>
  <data name="NotPredicateNull" xml:space="preserve">
    <value>not be null</value>
  </data>
  <data name="NotPredicateOverlap" xml:space="preserve">
    <value>not overlap</value>
  </data>
  <data name="NotPredicateReferenceType" xml:space="preserve">
    <value>not be reference type</value>
  </data>
  <data name="NotPredicateSame" xml:space="preserve">
    <value>not be same</value>
  </data>
  <data name="NotPredicateSatisfyAll" xml:space="preserve">
    <value>not satisfy all</value>
  </data>
  <data name="NotPredicateSatisfyAny" xml:space="preserve">
    <value>not satisfy any</value>
  </data>
  <data name="NotPredicateSequenceEqual" xml:space="preserve">
    <value>not be sequence-equal</value>
  </data>
  <data name="NotPredicateSetEqual" xml:space="preserve">
    <value>not be set-equal</value>
  </data>
  <data name="NotPredicateStartWith" xml:space="preserve">
    <value>not start with {Expected}</value>
  </data>
  <data name="NotPredicateStartWithSubstring" xml:space="preserve">
    <value>not start with substring {Expected}</value>
  </data>
  <data name="NotPredicateThrows" xml:space="preserve">
    <value>not to throw "{Expected}"</value>
  </data>
  <data name="NotPredicateTrue" xml:space="preserve">
    <value>not be true</value>
  </data>
  <data name="NotPredicateValueType" xml:space="preserve">
    <value>not be value type</value>
  </data>
  <data name="ParserErrorLinePosition" xml:space="preserve">
    <value>{0}, line {1}</value>
  </data>
  <data name="Passed" xml:space="preserve">
    <value>Explicitly passed</value>
  </data>
  <data name="Pending" xml:space="preserve">
    <value>Pending</value>
  </data>
  <data name="PossibleDelegateRetargeting" xml:space="preserve">
    <value>Delegate test data may need retargeting to work as expected, and you must explicitly opt-in using the proper attribute metadata or test types.</value>
  </data>
  <data name="PredicateAssignableFrom" xml:space="preserve">
    <value>be assignable from {Expected}</value>
  </data>
  <data name="PredicateBetween" xml:space="preserve">
    <value>to be between {Low} {High}</value>
  </data>
  <data name="PredicateContains" xml:space="preserve">
    <value>to contain {Expected}</value>
  </data>
  <data name="PredicateContainsSubstring" xml:space="preserve">
    <value>to contain substring "{Expected}"</value>
  </data>
  <data name="PredicateDistinct" xml:space="preserve">
    <value>be distinct</value>
  </data>
  <data name="PredicateEmpty" xml:space="preserve">
    <value>be empty</value>
  </data>
  <data name="PredicateEndWith" xml:space="preserve">
    <value>end with {Expected}</value>
  </data>
  <data name="PredicateEndWithSubstring" xml:space="preserve">
    <value>end with substring {Expected}</value>
  </data>
  <data name="PredicateEqual" xml:space="preserve">
    <value>be equal to {Expected}</value>
  </data>
  <data name="PredicateEqualDownloadContents" xml:space="preserve">
    <value>to equal download contents {Source}</value>
  </data>
  <data name="PredicateEqualFileContents" xml:space="preserve">
    <value>to equal file contents {FileName}</value>
  </data>
  <data name="PredicateFalse" xml:space="preserve">
    <value>be false</value>
  </data>
  <data name="PredicateGreaterThan" xml:space="preserve">
    <value>be &gt; {Expected}</value>
  </data>
  <data name="PredicateGreaterThanOrEqualTo" xml:space="preserve">
    <value>be &gt;= {Expected}</value>
  </data>
  <data name="PredicateHaveCount" xml:space="preserve">
    <value>have count {Expected}</value>
  </data>
  <data name="PredicateHaveKey" xml:space="preserve">
    <value>have key {ExpectedKey}</value>
  </data>
  <data name="PredicateHaveKeyWithValue" xml:space="preserve">
    <value>have key with value {ExpectedKey}={ExpectedValue}</value>
  </data>
  <data name="PredicateHaveLength" xml:space="preserve">
    <value>have length {Expected}</value>
  </data>
  <data name="PredicateHaveSingle" xml:space="preserve">
    <value>have single item</value>
  </data>
  <data name="PredicateInstanceOf" xml:space="preserve">
    <value>be instance of {Expected}</value>
  </data>
  <data name="PredicateLessThan" xml:space="preserve">
    <value>be &lt; {Expected}</value>
  </data>
  <data name="PredicateLessThanOrEqualTo" xml:space="preserve">
    <value>be &lt;= {Expected}</value>
  </data>
  <data name="PredicateMatch" xml:space="preserve">
    <value>match {Expected}</value>
  </data>
  <data name="PredicateMemberwiseEqual" xml:space="preserve">
    <value>be memberwise-equal</value>
  </data>
  <data name="PredicateNull" xml:space="preserve">
    <value>be null</value>
  </data>
  <data name="PredicateOverlap" xml:space="preserve">
    <value>overlap</value>
  </data>
  <data name="PredicateReferenceType" xml:space="preserve">
    <value>be reference type</value>
  </data>
  <data name="PredicateSame" xml:space="preserve">
    <value>be same</value>
  </data>
  <data name="PredicateSatisfyAll" xml:space="preserve">
    <value>satisfy all</value>
  </data>
  <data name="PredicateSatisfyAny" xml:space="preserve">
    <value>satisfy any</value>
  </data>
  <data name="PredicateSequenceEqual" xml:space="preserve">
    <value>be sequence-equal</value>
  </data>
  <data name="PredicateSetEqual" xml:space="preserve">
    <value>be set-equal</value>
  </data>
  <data name="PredicateStartWith" xml:space="preserve">
    <value>start with {Expected}</value>
  </data>
  <data name="PredicateStartWithSubstring" xml:space="preserve">
    <value>start with substring {Expected}</value>
  </data>
  <data name="PredicateThrows" xml:space="preserve">
    <value>to throw "{Expected}"</value>
  </data>
  <data name="PredicateTrue" xml:space="preserve">
    <value>be true</value>
  </data>
  <data name="PredicateValueType" xml:space="preserve">
    <value>be value type</value>
  </data>
  <data name="Sealed" xml:space="preserve">
    <value>Can't modify the object right now because it has been sealed from further modifications.</value>
  </data>
  <data name="SequenceNullConversion" xml:space="preserve">
    <value>Unexpectedly tried to assert on a sequence that was a null reference.</value>
  </data>
  <data name="TemporaryDirectoryFileNameRooted" xml:space="preserve">
    <value>Path must be an absolute path or navigate beyond the directory.</value>
  </data>
  <data name="TestFileDataRequiresOneParameter" xml:space="preserve">
    <value>TestFileDataAttribute can only be used on theories with one parameter.</value>
  </data>
  <data name="TestTimedOut" xml:space="preserve">
    <value>Test timed out.  Allowed execution time {0} was execeeded</value>
  </data>
  <data name="TheoryHasNoDataProviders" xml:space="preserve">
    <value>No test data for theory</value>
  </data>
  <data name="UContextLines" xml:space="preserve">
    <value>Show as many lines of context in unified diffs</value>
  </data>
  <data name="UExclude" xml:space="preserve">
    <value>Skip tests whose descriptions or names match the given {{PATTERN}}</value>
  </data>
  <data name="UExcludePattern" xml:space="preserve">
    <value>Skip tests whose full names match {{REGEX}}</value>
  </data>
  <data name="UFailFast" xml:space="preserve">
    <value>Exit when the first test fails</value>
  </data>
  <data name="UFailFocused" xml:space="preserve">
    <value>Exit with an error code if any focused specs</value>
  </data>
  <data name="UFailOnPending" xml:space="preserve">
    <value>Exit with an error code if any pending specs</value>
  </data>
  <data name="UFixture" xml:space="preserve">
    <value>Include a fixture search {{PATH}}</value>
  </data>
  <data name="UFocus" xml:space="preserve">
    <value>Focus tests whose descriptions or names match the given {{PATTERN}}</value>
  </data>
  <data name="UFullStackTraces" xml:space="preserve">
    <value>Don't hide f-spec stack frames in exception stack traces</value>
  </data>
  <data name="UHelp" xml:space="preserve">
    <value>Display this help screen</value>
  </data>
  <data name="UInclude" xml:space="preserve">
    <value>Run tests whose full names match the given {{PATTERN}}</value>
  </data>
  <data name="UIncludePattern" xml:space="preserve">
    <value>Run tests whose full names match {{REGEX}}</value>
  </data>
  <data name="ULoaderOptions" xml:space="preserve">
    <value>Loader options</value>
  </data>
  <data name="ULoaderPath" xml:space="preserve">
    <value>Add {{PATH}} to loader path</value>
  </data>
  <data name="UNoConfig" xml:space="preserve">
    <value>Don't load configuration from .fspecrc or .fspec cache</value>
  </data>
  <data name="UNoDiff" xml:space="preserve">
    <value>Don't use unified diffs when assertion messages contain long strings</value>
  </data>
  <data name="UNoFocus" xml:space="preserve">
    <value>Ignore all focused elements and run everything</value>
  </data>
  <data name="UNoRandomizeSpecs" xml:space="preserve">
    <value>Don't randomize specs</value>
  </data>
  <data name="UNoSummary" xml:space="preserve">
    <value>Don't show test run summary of failed tests at the end</value>
  </data>
  <data name="UNoWhitespace" xml:space="preserve">
    <value>Don't use special characters when printing whitespace in assertion failure messages</value>
  </data>
  <data name="UnusableComparer" xml:space="preserve">
    <value>Unable to compare values using the specified comparer</value>
  </data>
  <data name="UOutputOptions" xml:space="preserve">
    <value>Output options</value>
  </data>
  <data name="UPackage" xml:space="preserve">
    <value>Load the NuGet package dependency {{FORMULA}}</value>
  </data>
  <data name="UPause" xml:space="preserve">
    <value>Attach tty and wait for a keypress before exiting</value>
  </data>
  <data name="UPlanTimeout" xml:space="preserve">
    <value>Specify the maximum {{TIME}} allowed for the test plan to execute</value>
  </data>
  <data name="UPreviousFailures" xml:space="preserve">
    <value>Run the tests that failed in the previous test run, or all tests if no previous run</value>
  </data>
  <data name="UProjectDir" xml:space="preserve">
    <value>Change directory into the specified {{PROJECT}} directory</value>
  </data>
  <data name="URandom" xml:space="preserve">
    <value>Use the specified {{SEED}} to randomize specs</value>
  </data>
  <data name="URunnerOptions" xml:space="preserve">
    <value>Runner options</value>
  </data>
  <data name="USelfTest" xml:space="preserve">
    <value>Run the self-tests and exit</value>
  </data>
  <data name="UShowPassExplicit" xml:space="preserve">
    <value>Display messages when Assert.Pass is used</value>
  </data>
  <data name="UShowTestNames" xml:space="preserve">
    <value>Display names of tests and test cases even on success</value>
  </data>
  <data name="UShowWhitespace" xml:space="preserve">
    <value>Use special characters when printing whitespace in assertion failure messages</value>
  </data>
  <data name="USlowTest" xml:space="preserve">
    <value>Threshold {{TIME}} span for whether a test is considered slow</value>
  </data>
  <data name="UTag" xml:space="preserve">
    <value>Run tests with the specified TAG.  (Optionally, ~TAG for tests without tag)</value>
  </data>
  <data name="UTestSelectionOptions" xml:space="preserve">
    <value>Test selection options</value>
  </data>
  <data name="UTimeout" xml:space="preserve">
    <value>Specify the maximum {{TIME}} allowed for any particular test to execute</value>
  </data>
  <data name="UVerify" xml:space="preserve">
    <value>Use the specified verification {{MODE}} (either strict or none) to check for errors in tests and assertions</value>
  </data>
  <data name="UVersion" xml:space="preserve">
    <value>Report the version information and exit</value>
  </data>
  <data name="WrongNumberOfTheoryArguments" xml:space="preserve">
    <value>Test case #{0} for theory method {1}.{2} has incorrect number of arguments.</value>
  </data>
</root>